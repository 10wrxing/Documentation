Preferences & Settings
======================

The preferences section of a SmartApp specifies what
kinds of devices and other information is needed in order for the
application to be able to run. Inputs for each of these are presented to the user
during installation of the SmartApp from the mobile UI. You can present all of these
inputs on a single page, or break them up into multiple pages. In the case of multi-page
preferences, the content of each page can be static, i.e. consist of a fixed set of inputs
that never varies, or dynamic, where the number and types of inputs can depend on the inputs
of previous pages and other data sources.

Single Preferences Page
-----------------------

A single page preferences declaration is composed of one or more *section* elements, which in-turn contain one or more
*input* elements. The mobile UI renders whitespace between sections, which can have titles but don't have to. Single
page preferences automatically include app name and mode control inputs. For a simple app you might write:

::

    preferences {
        section("When activity on any of these sensors") {

            input "contactSensors", "capability.contactSensor",
                title: "Open/close sensors", multiple: true

            input "motionSensors", "capability.motionSensor",
                title: "Motion sensors?", multiple: true
        }
        section("Turn on these lights") {
            input "switches", "capability.switch", multiple: true
        }
    }

Which would be rendered in the mobile app UI as:

.. image:: ../img/smartapps/single-page-preferences.png


Multiple Preferences Pages
--------------------------

Preferences can also be broken up into multiple pages. When that's done each page contains contains one or more *section*
elements. The pages are nammed and the *nextPage* directive is used to define the flow between pages. Unlike with single
page preferences, the app name and mode control fields are not automatically added, and must be specified on the
desired page or pages. There are also *install* and *uninstall* directives that control the presence of the buttons
to install and uninstall the app. Breaking the previous example up into three pages would look like:

::

    preferences {
        page(name: "pageOne", title: "When there's activity on any of these sensors", nextPage: "pageTwo", uninstall: true) {
            section("Choose sensors to trigger the action") {

                input "contactSensors", "capability.contactSensor",
                    title: "Open/close sensors", multiple: true

                input "motionSensors", "capability.motionSensor",
                    title: "Motion sensors?", multiple: true
            }
        }
        page(name: "pageTwo", title: "Turn on these lights", nextPage: "pageThree") {
            section {
                input "switches", "capability.switch", multiple: true
            }
        }
        page(name: "pageThree", title: "Name app and configure modes", install: true, uninstall: true) {
            section([mobileOnly:true]) {
                label title: "Assign a name", required: false
                mode title: "Set for specific mode(s)", required: false
            }
        }
    }

The resulting pages in the mobile app would show the name and mode control fields only on the third page, and the
uninstall button on the first and third pages:

.. image:: ../img/smartapps/multiple-page-preferences.png


Preference Elements & Inputs
----------------------------

Preference pages (single or multiple) are composed of one or more sections, each if which contains one or more of the
following elements.

**Element Types**

============  ==========================================================================================================
**Name**      **Purpose**
------------  ----------------------------------------------------------------------------------------------------------
app           Provides user-initiated installation of child apps. Typically used in solution modules
input         Allows the user to select devices or enter values to be used during execution of the smart app
label         Allows the user to name the app installation. Automatically generated by non-page preferences
mode          Allows the user to select which modes the app executes in. Automatically generated by non-page preferences
paragraph     Text that's displayed on the page for messaging and instructional purposes
icon          Allows the user to select an icon to be used when displaying the app in the mobile UI
href          A control that selects another preference page or external HTML page
============  ==========================================================================================================

Inputs are the most commonly used preference elements. They can be used to prompt the user to select devices that
provide a certain capability, devices of a specific type, or constants of various kinds. Input element method calls
take two forms. The "shorthand" form passes in the name and type unnamed as the require first two parameters, and any
other arguments as named options:

::

    input "temperature1", "number", title: "Temperature"

The second form explicitly specifies the name of each argument

::

    input(name: "color", type: "enum", title: "Color", options: ["Red","Green","Blue","Yellow"])

As with all Groovy method calls the parentheses are optional, in most cases. The supported input element arguments are:

**Input Element Arguments**

===========================  ===========================================================================================
**Name**                     **Function**
---------------------------  -------------------------------------------------------------------------------------------
name                         Name of the variable injected into the SmartApp to reference this input
type                         One of the names from the following table
title                        Text that appears on the preferences page identifying this element
description                  Text that appears in place of the element value when it has yet to be set
multiple                     ``true`` to allow multiple values or ``false`` to allow only one value. Not supported for
                             all element types
required                     ``true`` to require an entry to save the page or ``false`` if the input is optional
===========================  ===========================================================================================

The currently supported input element types are:

**Input Types**

===========================  ===========================================================================================
**Name**                     **Function**
---------------------------  -------------------------------------------------------------------------------------------
cacapability.capabilityName  Prompts for all the devices that match the specified capability.
                             See the *Preferences Reference* column of the `capabilities <https://graph.api.smartthings.com/ide/doc/capability>`__
                             table for possible values.
device.deviceTypeName        Prompts for all devices of the specified type.
boolean                      A ``true`` or ``false`` value
date                         A calendar date value
decimal                      A floating point number, i.e. one that can contain a decimal point
email                        An email address
enum                         One of a set of possible values
hub                          Prompts for the selection of a hub
icon                         Prompts for the selection of an icon image
number                       An integer number, i.e. one without decimal point
password                     A password string. The value is obscured in the UI and encrypted before storage
phone                        A phone number
time                         A time of day
text                         A text value
===========================  ===========================================================================================



Dynamic Preferences
-------------------

One of the most powerful features of multi-page preferences is the ability to dynamically generate the content of a page
based on previous selections or external inputs, such as the data elements returns from a web services call. The
following example shows how to create a two preference page SmartApp where the content of the second page depends
on the selections made on the first page.

::

     preferences {
        page(name: "page1", title: "Select sensor and actuator types", nextPage: "page2", uninstall: true) {
            section {
                input("sensorType", "enum", options: [
                    "contactSensor":"Open/Closed Sensor",
                    "motionSensor":"Motion Sensor",
                    "switch": "Switch",
                    "moistureSensor": "Moisture Sensor"])

                input("actuatorType", "enum", options: [
                    "switch": "Light or Switch",
                    "lock": "Lock"]
                )
            }
        }

        page(name: "page2", title: "Select devices and action", install: true, uninstall: true)

    }

    def page2() {
        dynamicPage(name: "page2") {
            section {
                input(name: "sensor", type: "capability.$sensorType", title: "If the $sensorType device")
                input(name: "action", type: "enum", title: "is", options: attributeValues(sensorType))
            }
            section {
                input(name: "actuator", type: "capability.$actuatorType", title: "Set the $actuatorType")
                input(name: "action", type: "enum", title: "to", options: actions(actuatorType))
             }

        }
    }

    private attributeValues(attributeName) {
        switch(attributeName) {
            case "switch":
                return ["on","off"]
            case "contactSensor":
                return ["open","closed"]
            case "motionSensor":
                return ["active","inactive"]
            case "moistureSensor":
                return ["wet","dry"]
            default:
                return ["UNDEFINED"]
        }
    }

    private actions(attributeName) {
        switch(attributeName) {
            case "switch":
                return ["on","off"]
            case "lock":
                return ["lock","unlock"]
            default:
                return ["UNDEFINED"]
        }
    }

